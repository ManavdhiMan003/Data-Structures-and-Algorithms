#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define loop(i,n) for(i=0;i<n;i++)
#define loop1(i,k,n) for(i=k;i<n;i++)
#define pb push_back
typedef long long int ll;
struct bstnode{
    int data;
    bstnode* left;
    bstnode* right;
};
bstnode* getnode(int x){
    bstnode* temp = new bstnode();
    temp->data=x;
    temp->left=temp->right=NULL;
    return temp;
}
void insert(bstnode** root,int x){
    if((*root)==NULL){
        *root=getnode(x);
        return;
    }
    if((*root)->data>x){
      insert(&((*root)->left),x);
    }
    else{
        insert(&((*root)->right),x);
    }
    return;
}
// bstnode* insert(bstnode root,int x){
//     if(root==NULL){
//         root=getnode(x);
//         return root;
//     }
//     if(x<root->data){
//         root->left=insert(root->left,x);
//     }
//     else{
//         root->right=insert(root->right,x);
//     }
//     return root;
// }
bool search(bstnode* root,int x){
    if(root==NULL) return false;
    else if(root->data==x) return true;
    else if(x<=root->data)  return  search(root->left,x);
    else  return search(root->right,x);
}
void inorder(bstnode* root){
    if(root==NULL){
        return;
    }
    inorder(root->left);
    cout<<root->data<<" ";
    inorder(root->right);
    return;
}

int findmin(bstnode* root){
    bstnode* curr=root;
    if(root==NULL){
        return -1;
    }
    while(curr->left!=NULL){
        curr=curr->left;
    }
    return curr->data;
}
bstnode* findmin2(bstnode* root){
    bstnode* curr=root;
    // if(root==NULL){
    //     return root;
    // }
    while(curr && curr->left!=NULL){
        curr=curr->left;
    }
    return curr;
}
int findmax(bstnode* root){
    bstnode* curr=root;
    if(root==NULL){
        return -1;
    }
    else if(root->right==NULL)  return root->data;
    return findmax(root->right); 
}
int findheight(bstnode* root){
    if(root==NULL)  return -1;
    return max(findheight(root->left),findheight(root->right))+1;
}
void levelorder(bstnode* root){
    if(root==NULL) return;
    queue<bstnode*> q;
    q.push(root);
    while(!q.empty()){
        bstnode* curr=q.front();
        cout<<curr->data<<" ";
        if(curr->left!=NULL)    q.push(curr->left);
        if(curr->right!=NULL)    q.push(curr->right);
        q.pop();
    }
}
///     INEFFICIENT APPROCH
bool islesser(bstnode* root,int value){
    if(root==NULL) return true;
    if((root->data <= value)&&(islesser(root->left,value))&&(islesser(root->right,value))){
        return true;
    }
    return false;
}
bool isgreater(bstnode* root,int value){
    if(root==NULL) return true;
    if((root->data > value)&&(isgreater(root->left,value))&&(isgreater(root->right,value))){
        return true;
    }
    return false;
}
bool isbst(bstnode* root){
    if(root==NULL) return true;
    if((islesser(root->left,root->data))&&(isgreater(root->right,root->data))&&(isbst(root->left))&&(isbst(root->right))){
        // cout<<"Yes";
        return true;
    }
    return false;
}
//      EFFECTIVE FOR IS BINARY SEACRH TREE
bool isbstutil(bstnode* root,int minv,int maxv){
    if(root==NULL) return true;
    if(root->data>=minv&&root->data<maxv&&isbstutil(root->left,minv,root->data)&&isbstutil(root->right,root->data,maxv)){
        return true;
    }
    return false;
}
bool isbste(bstnode* root){
    return isbstutil(root,INT_MIN,INT_MAX);
}
bstnode* Delete(bstnode* root,int data){
    if(root==NULL)  return root;
    else if(data<root->data)    root->left = Delete(root->left,data);
    else if(data>root->data)    root->right = Delete(root->right,data);
    else{
        if(root->left==NULL && root->right==NULL){
            delete root;
        }
        else if(root->left==NULL){
            bstnode* temp=root;
            root=root->right;
            delete temp;
        }
        else if(root->right==NULL){
            bstnode* temp=root;
            root=root->left;
            delete temp;
        }
        else{
            bstnode* temp=findmin2(root->right);
            root->data=temp->data;
            root->right=Delete(root->right,temp->data);
        }
    }
    return root;
}
int floor(bstnode* root,int value){
    if(root==NULL) return INT_MAX; 
    if(root->data==value) return value;
    if(root->data>value) return floor(root->left,value);
    int floorvalue = floor(root->right,value);
    return (floorvalue<=value)?floorvalue:root->data;
}
int Ciel(bstnode* root,int value){
    if(root==NULL) return -1; 
    if(root->data==value) return value;
    if(root->data<value) return Ciel(root->right,value);
    int cielvalue = Ciel(root->left,value);
    return (cielvalue>=value)?cielvalue:root->data;
}
bool iscProperty(bstnode* root){
    if(root==NULL) return true;
    if(root->left==NULL&&root->right==NULL) return true;
    int sum=0;
    if(root->left!=NULL) sum+=root->left->data;
    if(root->right!=NULL) sum+=root->right->data;
    if(sum==root->data&&iscProperty(root->right)&&iscProperty(root->left)) return true;
    return false;
}
void printglevel(bstnode* root,int k){
    if(root==NULL) return;
    if(k==0) cout<<root->data<<" ";
    printglevel(root->left,k-1);
    printglevel(root->right,k-1);
    return;
}

int main(){
    bstnode* root=NULL;
    insert(&root,7);
    insert(&root,4);
    insert(&root,9);
    insert(&root,1);
    insert(&root,6);
    insert(&root,65);
    // root=insert(root,7);
    // root=insert(root,4);
    // root=insert(root,9);
    // root=insert(root,1);
    // root=insert(root,6);
    // root=insert(root,65);
    inorder(root);
    int n;
    cin>>n;
    cout<<(root==NULL)<<endl;
    if(search(root,n)==true)    cout<<"found"<<endl;
    else cout<<"not found\n";
    cout<<findmin(root)<<endl;
    cout<<findmax(root)<<endl;
    cout<<findheight(root)<<endl;
    levelorder(root);
    cout<<endl<<isbst(root);
    cout<<endl<<isbste(root)<<endl;
    root=Delete(root,4);
	// detede
    // levelorder(root);
    insert(&root,64);
    // root=insert(root,64);
//hello change from new branch pakka 
    levelorder(root);
    cout<<endl;
    insert(&root,45);
    // root = insert(root,45);
    levelorder(root);
    cout<<endl;
    cout<<floor(root,8)<<endl;
    cout<<Ciel(root,8)<<endl;
    printglevel(root,2);
    return 0;
}